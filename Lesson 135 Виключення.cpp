//Exception
/*
1.  Проблеми обробки помилок
2.  Що таке виключення? 
	Обработка исключений обеспечивает механизм
	отделения обработки ошибок от общего потока
	выполнения кода.
	Генерация исключений или «выбрасывание исключения» -
	это сигнализирование о том, что произошло
	исключение.
3.  Ключові слова try, catch, throw.
	
	Оператор throw исполозоуется для генерации исключений 
	или ошибок в С++:

		throw value;
	где value - значение любого типа данных, которое будет
	сигнализировать об ошибке.

	Блок try ответственен за поиск исключений в С++. Он
	сигнализирует компилятору о генерации исключений.
		
		try {блок стейтментов;}

	Блок catch ответственен за обработку исключений в С++.
		
		catch (параметры) {обработка исключения}

	Параметры одного блока catch могут быть доступны и
	в другом блоке catch (который находится за ним). Если
	параметр не используется в блоке catch, то имя
	переменной можно не указывать.

	Что обычно делают блоки catch?
	➢ Во-первых, блок catch может вывести сообщение об
	ошибке (либо в консоль, либо в лог-файл)
	➢ Во-вторых, блок catch может возвратить значение
	или код ошибки обратно в caller.
	➢ В-третьих, блок catch может сгенерировать другое
	исключения. Поскольку блок catch не находится
	внутри блока try, то новое сгенерированное
	исключение будет обрабатываться следующим
	блоком try.

	Каждый блок try должен сопровождаться хотя бы одним 
	блоком catch.

	try
	{
		// code that throw exсeption
	}
	catch(exception try)
	{
		// exception handling
	}

4.  Що буде, якщо не зловити виключення?
	Когда main() завершает свое выполнение с
	необработанным исключением, то операционная
	система обычно уведомляет нас о том, что произошла
	ошибка необработанного исключения.

5.  Декілька catch
6.  Блок try в блоці try
7.  Повторне кидання виключення
	Внутри блока catch может генерироваться новое
	исключение. Поскольку это новое исключение
	выбрасывается за пределами блока try, связанного с
	этим блоком catch, то оно не будет перехвачено
	текущим блоком catch (в котором выброшено).
	Исключения можно повторно выбрасывать в блоке catch
	с помощью ключевого слова throw без указания
	какого-либо идентификатора.

8.  Один catch для всіх виключень
	Обработчик catch-all - механизм обнаружения и
	обработки всех типов исключений. Он работает так же,
	как и обычный блок catch, за исключением того, что
	вместо обработки исключений определенного типа
	данных, он использует эллипсис	(...) в качестве типа
	данных. Использование обработчик catch-all защищает
	программу от непойманных исключений и связанных с
	ними ошибок
9.  Стандартні ієрархії виключень із бібліотеки
	https://en.cppreference.com/w/cpp/error/exception
10. Кидання виключень і наслідування
	 A <- B < - C
	 A - базовий клас
	 B - похідний клас
	 C - похідний клас від B

	 try
	 {}
	 catch (C)
	 {}
	 catch (B)
	 {}
	 catch (A)
	 {}
	 catch (...)
	 {}

11. Копіювання об'єкту при throw
12. Розкрутка стеку (Stack Unwinding)
	При выбрасывании исключения происходит
	разворачивание стека. Это означает, что все
	локальные переменные, которые были созданы в
	блоке try, будут уничтожены. Если в блоке try
	находится несколько блоков catch, то они
	выполняются в обратном порядке их создания.
	Разворачивание стека - это процесс удаления
	объектов из стека вызовов, когда происходит
	исключение. Этот процесс позволяет избежать
	утечек памяти и других проблем с памятью.

13. Специфікація виключень throw(...)
14. Специфікація виключень noexcept
15. Оператор noexcept()
16. Кидання виключень в конструкторах - заборонено
17. Кидання виключень в деструкторах - заборонено
    Если очень надо, можно добавить исключение в 
	деструктор, но только  с одновременной 
	обработкой исключения.

18. throw між new і delete - заборонено
	С разумными указетлями можно кидать исключения.

19. Незручності при роботі з виключеннями:
	➢ Необхідно обробляти виключення
	➢ Необхідно знати, які виключення можуть бути
	викликані
	➢ Сповыльнення програми
	➢ Розкрутка стеку
*/

#include <iostream>

struct MeException
{
	int errorCode;
	char errorMassage[50];
};

void InterestingFunction()
{
	int randomNumber = std::rand() % 3;

	try
	{
		if (randomNumber == 0)
		{
			throw MeException{- 1, "Incorrect random number"};
		}
		else if(randomNumber==1)
		{
			throw 's';
		}
		else if (randomNumber == 3)
		{
			throw 2.5;
		}
	}
	catch (const MeException exc)
	{
		std::cout << "Function name: "<<__func__<<std::endl;
		std::cout << "Error code = " << exc.errorCode<<"\n\n";

		throw;
	}
	
}

void Func1() throw() {} //функція не кидає виключення
void Func2() throw(...) {} //функція кидає виключення будь-якого типу
void Func3() throw(MeException, std::exception, std::bad_alloc) {} //функція кидає виключення MeException, std::exception, std::bad_alloc

void Func4() noexcept {} //функція не кидає виключення
void Func5() noexcept(false) {} //функція кидає виключення
void Func6() noexcept(true) {} //функція не кидає виключення

int main() 
{
	std::exception object1;
	std::exception object2("My own exception");
	std::exception object3(object2);
	std::exception object4;
	object4 = object2;

	/*try
	{
		InterestingFunction();
	}
	
	catch (int errorInteger)
	{
		std::cout << errorInteger;
	}
	catch (char errorCharacter)
	{
		std::cout << errorCharacter;
	}
	catch (double errorDouble)
	{
		std::cout << errorDouble;
	}
	catch (...)
	{
		std::cout << "Error.\n";
	}*/

	if (noexcept(Func4()))
	{
		std::cout << "Func4() не кидає виключення\n";
	}
	else
	{
		std::cout << "Func4() кидає виключення\n";
	}



	return 0;
}
 